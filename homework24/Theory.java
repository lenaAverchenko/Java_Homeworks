package de.telran.averchenko.elena.homework24;

public class Theory {

    /*
    * 1. Pattern - это объект-шаблон, используемый для регулярных выражений. Для создания объекта этого класса нужно использовать
    *    метод compile() с аргументом - регулярным выражением.
    *    Mathcer - объект, который отвечает за поиск. Сопоставление строки переданной и регулярного выражения паттерна.
    *
    * 2. Алгоритм поиска в Matcher работает жадно, это значит, что он возвращает абсолютно все, что подходит под описание
    *    регулярного выражения.
    *    Более ленивый поск возможен с использованием спец.символов " ? ", " +? ".
    *    "?" означает, что некое вхождение может быть, а может не быть
    *
    * 3. PatternSyntaxException может быть выброшен, если на входе невалидный паттерн, какая-то синтаксическая ошибка. Мы можем
    *    получить описание ошибки, индекс символа, где именно произошла ошибка.
    *
    * 4. "." означает каждый символ (Character). Поиск выглядит так: "{.}"
    *    "\\" - это будет поиск по символу "\". Тут требуется экранирование, и поэтому используется двойной бэкслеш. Экранирование
    *    необходимо, поскольку "\" применяется в других запросах, например, для переноса строки, символ табуляции и т.д.
    *
    * 5. * - вхождение может быть любое число раз, но оно может и не встретиться
    * + - символ, указанный перед этим знаком, встретится хотя бы 1 раз
    * ? - вхождение символа перед указанным знаком может быть, а может не быть
    * {3,5} - от 3 до 5 раз
    *
    * 6. Создаем паттерн: Pattern pattern = Pattern.compile("ab").
    *    А затем проверяем совпадает ли оно с нашим текстом, при помощи метода matches(). "^   регулярное выражение   $"
    *    дадут гарантию, что перед и за спец.значами ничего не будет, значит, совпадение должно быть полным.
    *    ^ - начинаем с символа после, $ - конец строки
    *
    * 7. [^a] - такое выражение исключит символ "а" из поиска
    *
    * 8. Дать имя группе можно с помощью символов: "(?<имя группы> само выражение)".
    *    ((A(B))(C)) - номер скобки соответствует номеру группы, если считать с 1, поскольку нулевой - это вся строка.
    *    Значит, 1 - (A(B)), а 3 - (C)
    *
    * 9. StringBuilder vs String:
    *    StringBuilder работает оптимальнее. Это собиратель строк, и сбор он делает на ходу. В то время, как String является
    *    неизменяемым, а значит, каждое изменение в строке - это новая строка, и новый занятый объем памяти.
    *
    *
    *
    *
    *
    *
    *
    *
    *
    *
    * */

}
