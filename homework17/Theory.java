package de.telran.averchenko.elena.homework17;

public class Theory {
    /*
    1. Лямбда-выражения - реализует метод функционального интерфейса. Операции:
       а) Объявление переменной. Задание переменной для дальнейшего использования.
       б) Определение, объявление функции, по которой будет вестись рассчет.
       в) Применение функции для определенного параметра

    2. Функциональный интерфейс - это интерфейс, у которого есть только 1 метад для реализации. У него может быть
       сколько угодно реализованных методов, статических, может быть дефолтный метод. Но для реализации - абстрактный
       - только 1. Может быть также метка @FunctionalInterface.

    3. @FunctionalInterface - это метка (аннотация) не является обязательной, но желательна, чтобы не допустить ошибку,
       и сделать только 1 метод абстрактным.

    4. Анонимный класс. Он существует внутри класса, и только там, для единоразового использования. Ранее их применяли вместо
       лямбда выражений.

    5. По сути лямбда - реализация функционального интерфейса, и она же представляет собой анонимный класс, который реализует
       анонимный метод.
       синтаксис: (параметры) -> {реализация}.
       - Мы должны задать параметры.
       - Определить ссылку на функциональный интерфейс.
       - Создать реализвацию этого интерфейса (это как бы "присвоение" метода - функции заданной ссылке на интерфейс.)
       - Вызываем метод через переопределенное выражение.

    6. Функциональные интерфейсы:
       - Функции (когда есть 1 входной и 1 выходной (с прмименением к входному некой мат. операции) параметры)
       - BiFunction (будет 2 входных параметра, и 1 выходной)
       - Consumer - входные параметры есть и никаких параметров на выходе (может быть просто распечатка)
       - Supplier - никаких входных и 1 выходной параметр



     */
}
