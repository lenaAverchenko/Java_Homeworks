package de.telran.averchenko.elena.homework11;

public class Theory {
    // 1. Queue - это очередь, действует по принципу - первый зашел, первый вышел (First-in-First-Out);
    //    Stack - работает по принципу (First-in-Last-Out)

    // 2. Stack можно заменить Deque, что является двунаправленной очередью, соответственно можно сделать
    //    принцип аналогичный Stack, с разницей, что Stack - потокобезопасный, а Deque - нет, но и работает он быстрее.

    // 3. Deque имеет реализации: LinkedList(связанный список), ArrayDeque (массив с динамически растущей емкостью - зацикленный массив,
    //    не принимающий null, реализует Queue, Deque)

    // 4. ArrayDequeue под капотом - зацикленный массив с динамически растущей емкостью. Тогда получается, что у нас между
    //    первым и последним элементом есть пустые места. И мы будем добавлять в них как перед первым, так и после последнего
    //    до тех пор, пока будут свободные ячейки (пока не произойдет встреча последнего и первого элементов.)

    // 5. PriorityQueue - стандартно по дефолту приоритет выставлен, например, по алфафиту, либо по числовому порядку.
    //    Если нам нужен какой-то другой способ отбора приоритетного значения, мы можем использовать компаратор.

    // 6. Маркерные интерфейсы - это те, которые не требуют переопределения методов, потому как их нет. При этом,
    //    они "помечают", что определенные классы могут делать что-то. Мы даем дополнительную информацию об объекте для компилятора.
    //    Например:
    //    Serializable - имплиментируя этот интерфейс, мы говорим, что объекты нашего класса могут быть сериализованы, т.е.
    //    переведены в набор байтов
    //    Cloneable - не имплиментировав этот интерфейс, клонировать объект текущего класса с помощью clone() не получится.
    //    RandomAccess - его реализация дает возможность быстро находить элемент по индексу.

    // 8. Push to stack:
    //285
    //Push to arrayDeque:
    //407
    //Push to linkedList:
    //494
    //Pop from stack:
    //47
    //Pool from arrayDeque:
    //16
    //Pool from linkedList:
    //47

    // Когда мы кладем новые элементы в Stack, мы просто вкладываем их сверху, когда LinkedList должен еще добавить привязки к
    // соседним элементам, а АrrayDeque должен периодически расширяться.
    // Удаление происходит быстрее в АrrayDeque, полагаю, потому как тут просто происходит изменение размера, когда в Stack
    // возможно, влияет на скорость еще и потокобезопасность, а в LinkedList - переписываение ссылок на соседние элементы.

    // Насчет скорости я бы еще уточнила.
}
