package de.telran.averchenko.elena.homework12;

public class Theory {
    // 1. Копирование осуществляется припомощи clone(). И копируется так сам объект, ссылаясь на поля предыдущего оьъекта.
    //    А это значит, что любые изменения в полях(которые тоже - объекты, не примитивы) исходного объекта приведут к тому,
    //    что в копированном тоже будут эти изменения. При этом класс объекта должен быть cloneable(), чтобы его можно
    //    было клонировать.
    //    DeepCopy - предполагает, что копируя текущий объект, мы также будем копировать поля-объекты, на которые ссылается
    //    объект. И перемены в полях исходного объекта уже не повлияют на дочерний. Для этого нужно переопределить метод
    //    clone(), сделав так, чтобы копируя основной объект, также осуществлялись копии объектов - полей, на которые он ссылается.
    //    clone() должен быть вызван в методе clone() основного объекта для каждого его поля отдельно.
    //    Так, вызвав clone(), будет скопирована как оболочка объекта, так и его поля (они уже не будут привязаны друг к другу).

    // 2. hash - математическая функция (алгоритм), который преобразует данные в уникальный набор букв и цифр определенной длины.
    //    Она для определенного значения (с определенным алгоритмом кодировки) будет неизменна при многократном вызове;
    //    Сама по себе функция простая, и быстро вычисляется;
    //    Даже при незначительном изменении значения хэш-функция вернет совершенно другой результат;
    //    По значению хеш-функции нельзя вернуть значение, которое было закодировано.
    //    hashCode() в Java вернет значение int, но принцип ее тот, что описан выше.

    // 3. Коллизия - может возникнуть, если в очередной момент объектов, которые хэшируются, становится больше, чем значений,
    //    которые может вернуть hashCode(). Тогда разным объектам может вернуться одинаковое значение функции.
    //    По идее, каждое значение хэш-функции должно определить ячейку для хранения данных, которые этой функцией были
    //    хэшированны.
    //    Решения:
    //    3.1. Открытая адрессация. Мы ищем ближайшую пустую ячейку и кладем данные с таким же значением хэшкода туда.
    //         Может быть так, что если мы не нашли в соседней, то потом будем смотреть через 2, 4,8 и т.д. ячеек, чтобы сделать
    //         разреженные данные. Также может быть вычислен hashCode() от hashCode() - и поместить можно в ту ячейку, если она свободна.
    //    3.2. Раздельная цепь. Можно также записывать значения с одинаковым хэшем в одну и ту же ячейку, создавая там подобие
    //         связанных списков. В последствии, при поиске по хэш, будет осуществляться сравнения значений по нескольким параметрам
    //         при помощи equals(). А чтобы не было потери памяти, и времени при поиске, если в 1 яцейке больше 8 элементов,
    //         связанный список меняется на упорядоченное дерево.

    // 4. HashMap работает по принципу: у каждого элемента есть ключ. Хранится в неких корзинах - бакетах. Изначально таких корзин 16,
    //    если мы нашли ключ при сравнении, то помещаем туда значение, в текущую корзину, если такого ключа еще нет, то поместим пару
    //    ключ и значение. Хранение в корзинах по принципу разделенной цепи.
}
