package de.telran.averchenko.elena.homework10;

public class Theory {
    // 1. а) если сравнение происходит с самим собой, результат должен быть всегда "true" (
    //       если мы сравним объект (а) с другим объектом, который ссылается на этот объект (а),
    //       то результат всегда должен быть "true")
    //    б) a.equals(b) и b.equals(a) должны давать тот же самый результат - симметричность
    //    в) Транзитивность: если объект 1 равен объекту 2, а объект 2 равен объекту 3 то и объект 1 должен быть
    //       равен объекту 3.
    //    г) любой объект, который мы сравним с null всегда должен давать false
    //    д) если состояние объектов не меняется, значит и сравнивая объекты a.equals(b) до и после применения методов
    //       будет одинаковым

    // 2. Строка - это объект, который работает немного иначе, чем другие. Ради экономии места и оптимизации строка хранится в
    //    в куче, но в String Pool, куда новые значения не просто добавляются, но еще и проверяются на дубликат, и если
    //    значения идентичны, то в новой строке будет просто создана ссылка на уже существующее значение.
    //    String something = new String ("some words").intern() - так мы с помощью new должны были создать новую ссылку на строку,
    //    но intern() заставит пойти посмотреть, нет ли такого значения в String Pool, и если оно есть, то принудительно
    //    новое значение создано не будет, а вернется ссылка.
    //    если нам нужно принудительно положить даже дубликат существующего в String Pool значения, пользуемся new:
    //    String something = new String ("some words").

    // 3. Comparator - интефейс - сравниватель, реализует метод compare(), и благодаря сравненивателю мы можем отсортировать
    //    наши объекты. Сравниваем тут мы по каждому параметру отдельно.
    //    Comparable - интерфейс, который реализуется каким-то конкретным классом, говоря о том, что его объекты можно сравнивать
    //    Реализован будет единственный метод compareTo(), и он сравнивает текущий объект с тем, что передан в параметр.
    //
    //    Если мы хотим создать TreeSet по какому-то объекту (типизировать), то класс, экземпляром которого этот объект является, должен быть
    //    Comparable.
    //    Если мы знаем, что объекты данного класса точно будут сравниваться, то можно класс сделать Comparable.
    //    Но, когда нам нужен сравниватель по какому-то одному значению, или мы не уверены, что это объект будет сравниваться,
    //    то проще вынести это в отдельный Comparator, их можно объединить и работать с каждым из них или с несколькими в разных порядках.

    // 4. Если мы реализуем Comparable, то метод compareTo() должен сравнивать объекты по тем же параметрым, по
    //    которым делает сравнение на равенство объектов equals()

}
