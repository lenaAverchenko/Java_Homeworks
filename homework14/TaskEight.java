package de.telran.averchenko.elena.homework14;

public class TaskEight {
    /**
     * Предположим, что вес ребра - это расстояние между городами
     * Значит, задача сведется к тому, что суммарный вес пройденных ребер должен быть минимальным.
     * Есле делать обход графа в глубину, можно помечать город как пройденный (обратно возвращаться в него нельзя).
     * Рассматриваем все варианты обхода графа.
     * Зашли в начальную вершину, пометили тем же серым, в другу - снова серым.
     * нужно записывать наименование каждой вершины(когда понимаем, что она еще не была пройдена),
     * чтобы понять, какова траектория.
     * также нужно записывать длину ребра (ее можно писать в общее число, определенное заранее, и просто суммировать с новым пройденным
     * ребром)
     * возвращаться в город, в котором уже были нельзя, поэтому, если следующий город уже помечен серым, мы просто не меняем
     * никакие параметры, а ищем дальше.
     * Может быть ситуация, когда мы окажемся в городе, при выходе из которого не будет незакрашенных вершин, и это значит, что такой путь
     * рассматривать нельзя, нужно делать обход заново.
     * Точкой выхода из текущего обхода будет нахождение указанного города - вершины.
     * Понятно, что если маршрут повторится по последовательности городов, его записывать не нужно.
     *
     * Не могу понять, что нужно, чтобы выйти из рекурсивного повторения метода по нахождению города. Что будет точкой выхода
     * - когда будут закончены обходы
     * Маршруты (ArrayList) и их длины хорошо бы записать в мапу, оттуда их можно будет сравнить и найти нужный по наименьшему ключу.
     *
     * Варианты: 5+3+4 = 12
     * 5+3+5+1 = 14
     * 5+3+5+9+2+2 = 26
     * 5+1+2+2 = 10
     * 5+1+9+1= 16
     * 5+1+9+5+4=24
     * 4+3+2+2=11
     * 4+3+1+3+4=14
     * 4+3+1+3+5+9+2+2 (тут не выйдет, т.к. Берлин уже будет закрашенным)
     * 4+3+1+3+5+1=17
     * 4+3+9+5+4=25
     * 4+3+9+1=17
     *
     * кратчайший выйдет 5+1+2+2 = 10 - он же Рейкявик - Осло - Берлин - Рим - Афины
     *
     *
     *
     *
     *
     *
     * */
}
